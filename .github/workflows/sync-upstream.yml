name: Sync Upstream and Build

on:
  schedule:
    - cron: '0 */6 * * *'  # Every 6 hours
  workflow_dispatch:        # Manual trigger
    inputs:
      force_build:
        description: 'Force build even if no new upstream release'
        required: false
        default: 'false'
        type: boolean

permissions:
  contents: write

jobs:
  check-upstream:
    name: Check for New Upstream Release
    runs-on: ubuntu-latest
    outputs:
      new_release: ${{ steps.check.outputs.new_release }}
      upstream_version: ${{ steps.check.outputs.upstream_version }}
      upstream_tag: ${{ steps.check.outputs.upstream_tag }}

    steps:
      - name: Checkout fork
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for new upstream release
        id: check
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Get latest upstream release tag
          UPSTREAM_TAG=$(gh release view --repo automazeio/vibeproxy --json tagName -q '.tagName' 2>/dev/null || echo "")

          if [ -z "$UPSTREAM_TAG" ]; then
            echo "Failed to get upstream release tag"
            echo "new_release=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          UPSTREAM_VERSION=${UPSTREAM_TAG#v}
          echo "Latest upstream: $UPSTREAM_TAG (version $UPSTREAM_VERSION)"

          # Get our latest release tag
          OUR_TAG=$(gh release view --json tagName -q '.tagName' 2>/dev/null || echo "")
          OUR_VERSION=${OUR_TAG#v}
          echo "Our latest: $OUR_TAG (version $OUR_VERSION)"

          semver_gt() {
            local a="$1"
            local b="$2"
            if [ -z "$a" ] || [ -z "$b" ]; then
              return 1
            fi
            if [ "$a" = "$b" ]; then
              return 1
            fi
            local top
            top=$(printf '%s\n' "$a" "$b" | sort -V | tail -n1)
            [ "$top" = "$a" ]
          }

          # Check if we need to sync (upstream version must be higher)
          if [ -z "$OUR_TAG" ]; then
            echo "No existing release tag found; treating upstream as new"
            echo "new_release=true" >> $GITHUB_OUTPUT
          elif [ "$UPSTREAM_TAG" = "$OUR_TAG" ]; then
            echo "Already synced with upstream $UPSTREAM_TAG"
            echo "new_release=false" >> $GITHUB_OUTPUT
          elif semver_gt "$UPSTREAM_VERSION" "$OUR_VERSION"; then
            echo "New upstream release detected: $UPSTREAM_TAG"
            echo "new_release=true" >> $GITHUB_OUTPUT
          else
            echo "Upstream $UPSTREAM_TAG is not newer than our $OUR_TAG"
            echo "new_release=false" >> $GITHUB_OUTPUT
          fi

          echo "upstream_version=$UPSTREAM_VERSION" >> $GITHUB_OUTPUT
          echo "upstream_tag=$UPSTREAM_TAG" >> $GITHUB_OUTPUT

  sync-and-patch:
    name: Sync and Apply Patches
    needs: check-upstream
    if: needs.check-upstream.outputs.new_release == 'true' || github.event.inputs.force_build == 'true'
    runs-on: ubuntu-latest
    outputs:
      sync_success: ${{ steps.sync.outputs.success }}

    steps:
      - name: Checkout fork
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Add upstream remote
        run: |
          git remote add upstream https://github.com/automazeio/vibeproxy.git || true
          # Fetch upstream tags into a namespaced ref to avoid clobbering fork tags.
          git fetch upstream "refs/tags/*:refs/tags/upstream/*"

      - name: Sync with upstream
        id: sync
        run: |
          set -e

          UPSTREAM_TAG="${{ needs.check-upstream.outputs.upstream_tag }}"
          UPSTREAM_TAG_REF="refs/tags/upstream/${UPSTREAM_TAG}"
          echo "Syncing to upstream tag: $UPSTREAM_TAG"

          # Create a new branch for the sync
          SYNC_BRANCH="sync-upstream-$UPSTREAM_TAG"
          git checkout -b "$SYNC_BRANCH" main

          # Merge upstream tag
          echo "Merging upstream $UPSTREAM_TAG_REF..."
          if git merge "$UPSTREAM_TAG_REF" -m "Merge upstream $UPSTREAM_TAG" --no-edit; then
            echo "Merge successful"
          else
            echo "Merge conflicts detected, resolving..."
            # For conflicts in managed files, prefer upstream version
            # These will be re-patched by update.sh
            git checkout --theirs src/Sources/AuthStatus.swift || true
            git checkout --theirs src/Sources/ServerManager.swift || true
            git checkout --theirs src/Sources/SettingsView.swift || true
            git checkout --theirs src/Info.plist || true
            git checkout --theirs src/Sources/AppDelegate.swift || true
            git add -A
            git commit -m "Merge upstream $UPSTREAM_TAG (resolved conflicts)" --no-edit || true
          fi

          # Apply patches
          echo "Applying patches..."
          chmod +x update.sh
          UPSTREAM_REF_OVERRIDE="$UPSTREAM_TAG_REF" ./update.sh --apply

          # Commit patched changes
          git add -A
          git commit -m "Apply fork patches for $UPSTREAM_TAG" || echo "No patch changes to commit"

          # Push the sync branch
          git push origin "$SYNC_BRANCH" --force

          # Update main branch
          git checkout main
          git merge "$SYNC_BRANCH" --no-edit
          git push origin main

          # Clean up sync branch
          git push origin --delete "$SYNC_BRANCH" || true

          echo "success=true" >> $GITHUB_OUTPUT

  # Call the patched-release workflow as a reusable workflow
  build-release:
    name: Build Patched Release
    needs: [check-upstream, sync-and-patch]
    if: needs.sync-and-patch.outputs.sync_success == 'true'
    uses: ./.github/workflows/patched-release.yml
    with:
      upstream_version: ${{ needs.check-upstream.outputs.upstream_version }}
    secrets: inherit
